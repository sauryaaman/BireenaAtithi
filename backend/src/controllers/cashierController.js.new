const moment = require('moment-timezone');

const getPaymentTrends = async (req, res) => {
  try {
    let { start_date, end_date } = req.query;
    const user_id = req.user?.user_id;
    const timezone = 'Asia/Kolkata';

    // Start from the beginning of the IST day in UTC
    // For Oct 25th IST 00:00:00, we need Oct 24th 18:30:00 UTC
    const startUtc = moment.tz(start_date, timezone)
      .startOf('day')                  // Get start of IST day
      .subtract(5, 'hours')            // Convert to UTC (part 1)
      .subtract(30, 'minutes')         // Convert to UTC (part 2)
      .format();

    // End at the end of the IST day in UTC
    // For Oct 25th IST 23:59:59, we need Oct 25th 18:29:59 UTC
    const endUtc = moment.tz(end_date, timezone)
      .endOf('day')                    // Get end of IST day
      .subtract(5, 'hours')            // Convert to UTC (part 1)
      .subtract(30, 'minutes')         // Convert to UTC (part 2)
      .format();

    console.log('Query parameters:', {
      input_dates: { start_date, end_date },
      ist_range: {
        start: moment.tz(start_date, timezone).startOf('day').format('YYYY-MM-DD HH:mm:ss'),
        end: moment.tz(end_date, timezone).endOf('day').format('YYYY-MM-DD HH:mm:ss')
      },
      utc_query_range: {
        start: startUtc,
        end: endUtc,
        start_ist: moment(startUtc).tz(timezone).format('YYYY-MM-DD HH:mm:ss'),
        end_ist: moment(endUtc).tz(timezone).format('YYYY-MM-DD HH:mm:ss')
      }
    });

    // Get transactions in UTC range
    const { data: transactions, error } = await supabase
      .from('payment_transactions')
      .select('amount_paid, payment_mode, created_at, is_refund')
      .eq('user_id', user_id)
      .gte('created_at', startUtc)
      .lte('created_at', endUtc)
      .order('created_at', { ascending: true });

    if (error) throw error;

    console.log(`Found ${transactions.length} transactions`);

    // Initialize map for each day in range
    const trendsMap = {};
    let currentDate = moment.tz(start_date, timezone).startOf('day');
    const endDateObj = moment.tz(end_date, timezone).startOf('day');

    while (currentDate.isSameOrBefore(endDateObj, 'day')) {
      const dateStr = currentDate.format('YYYY-MM-DD');
      trendsMap[dateStr] = {
        date: dateStr,
        total_payments: 0,
        total_refunds: 0,
        net_collection: 0,
        payment_count: 0,
        refund_count: 0,
        payments: { Cash: 0, Card: 0, UPI: 0, 'Bank Transfer': 0, Other: 0 },
        refunds: { Cash: 0, Card: 0, UPI: 0, 'Bank Transfer': 0, Other: 0 }
      };
      currentDate.add(1, 'day');
    }

    // Process transactions
    transactions.forEach(trans => {
      // Convert UTC timestamp to IST date
      const istDate = moment.tz(trans.created_at, 'UTC').tz(timezone).format('YYYY-MM-DD');
      
      console.log('Processing transaction:', {
        utc_time: trans.created_at,
        ist_time: moment.tz(trans.created_at, 'UTC').tz(timezone).format('YYYY-MM-DD HH:mm:ss'),
        ist_date: istDate,
        amount: trans.amount_paid,
        mode: trans.payment_mode,
        is_refund: trans.is_refund
      });
      
      if (!trendsMap[istDate]) {
        console.log('Warning: Transaction date mismatch:', {
          transaction_date: istDate,
          utc: trans.created_at,
          ist: moment.tz(trans.created_at, 'UTC').tz(timezone).format('YYYY-MM-DD HH:mm:ss'),
          valid_dates: Object.keys(trendsMap)
        });
        return;
      }

      const mode = trans.payment_mode || 'Other';
      const amount = Number(trans.amount_paid) || 0;

      if (trans.is_refund) {
        trendsMap[istDate].total_refunds += amount;
        trendsMap[istDate].refund_count += 1;
        trendsMap[istDate].refunds[mode] = (trendsMap[istDate].refunds[mode] || 0) + amount;
      } else {
        trendsMap[istDate].total_payments += amount;
        trendsMap[istDate].payment_count += 1;
        trendsMap[istDate].payments[mode] = (trendsMap[istDate].payments[mode] || 0) + amount;
      }

      trendsMap[istDate].net_collection = 
        trendsMap[istDate].total_payments - trendsMap[istDate].total_refunds;

      console.log(`Updated totals for ${istDate}:`, {
        payments: trendsMap[istDate].total_payments,
        refunds: trendsMap[istDate].total_refunds,
        net: trendsMap[istDate].net_collection,
        payment_count: trendsMap[istDate].payment_count,
        refund_count: trendsMap[istDate].refund_count
      });
    });

    // Sort and prepare final results
    const finalTrends = Object.values(trendsMap)
      .sort((a, b) => moment.tz(a.date, timezone).diff(moment.tz(b.date, timezone)));

    console.log('\nFinal summary by date:');
    finalTrends.forEach(day => {
      console.log(`${day.date}:`);
      console.log(`- Payments: ${day.payment_count} transactions totaling ${day.total_payments}`);
      console.log(`- Refunds: ${day.refund_count} transactions totaling ${day.total_refunds}`);
      console.log(`- Net collection: ${day.net_collection}`);
      console.log('- Payment modes:', day.payments);
      console.log('- Refund modes:', day.refunds);
      console.log('');
    });

    res.json(finalTrends);
  } catch (err) {
    console.error('Error in getPaymentTrends:', err);
    res.status(500).json({
      error: 'Internal server error',
      details: err.message
    });
  }
};

module.exports = {
    getSummary,
    getDailyTransactions,
    getPaymentTrends
};